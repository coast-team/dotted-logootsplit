/*
    Copyright (C) 2018  Victorien Elvinger

    This Source Code Form is subject to the terms of the Mozilla Public
    License, v. 2.0. If a copy of the MPL was not distributed with this
    file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

import { assert, heavyAssert } from "./assert"
import { isObject, FromPlain } from "../core/data-validation"
import { digestOf, isU32, u32 } from "./number"
import { Anchor } from "./anchor"
import { Pos, BaseOrdering } from "./pos"
import { Concat, ConcatLength } from "./concat"
import { IntervalOrdering, IntInterval } from "./int-interval"
import { Ordering } from "./ordering"

/**
 * Possible relation between two blocks.
 *
 * Same semantic as {@link IntervalOrdering }.
 * @example
 * [0, 2] |⊂ 1[_, _]
 */
export const enum BlockOrdering {
    // TODO: add "AfterVirtualBlock" & "BeforeVirtualBlock" (with better names)?
    BEFORE = -5, // <
    PREPENDABLE = -4, // <:
    OVERLAPPING_BEFORE = -3, // <∩
    SPLITTED_BY = -2, // |⊂
    INCLUDED_BY = -1, // ⊂
    EQUAL = 0, // =
    INCLUDING = 1, // ⊃
    SPLITTING = 2, // ⊃|
    OVERLAPPING_AFTER = 3, // >∩
    APPENDABLE = 4, // :>
    AFTER = 5, // >
}

/**
 * Map IntervalOrdering to BlockOrdering.
 */
const intervalOrderingAsBlockOrdering = Object.freeze({
    [IntervalOrdering.BEFORE]: BlockOrdering.BEFORE,
    [IntervalOrdering.PREPENDABLE]: BlockOrdering.PREPENDABLE,
    [IntervalOrdering.OVERLAPPING_BEFORE]: BlockOrdering.OVERLAPPING_BEFORE,
    [IntervalOrdering.INCLUDING]: BlockOrdering.INCLUDING,
    [IntervalOrdering.EQUAL]: BlockOrdering.EQUAL,
    [IntervalOrdering.INCLUDED_BY]: BlockOrdering.INCLUDED_BY,
    [IntervalOrdering.OVERLAPPING_AFTER]: BlockOrdering.OVERLAPPING_AFTER,
    [IntervalOrdering.APPENDABLE]: BlockOrdering.APPENDABLE,
    [IntervalOrdering.AFTER]: BlockOrdering.AFTER,
})

export interface BaseBlockk<P> {
    /**
     * First position of the block.
     */
    readonly lowerPos: P

    /**
     * Last position of the block.
     */
    readonly upperPos: () => P

    /**
     * Block length.
     */
    readonly length: u32
}

/**
 * Represent the removal of a segment.
 */
export type LengthBlock<P extends Pos<P>> = Block<P, ConcatLength>

/**
 * Segment of concatenable elements generated by a same participant.
 *
 * A segment can be represented as a set of int successive positions
 * (see {@link Pos }) and an attached content (items).
 */
export class Block<P extends Pos<P>, E extends Concat<E>> {
    /**
     * @param lowerPos First position of the block.
     * @param items Content of the block.
     */
    constructor(readonly lowerPos: P, readonly items: E) {
        assert(() => items.length > 0, "items.length > 0")
        assert(() => lowerPos.hasIntSucc(items.length - 1), "valid positions")
    }

    static fromPlain<P extends Pos<P>, E extends Concat<E>>(
        f: FromPlain<P>,
        g: FromPlain<E>
    ): FromPlain<Block<P, E>> {
        return (x: unknown) => {
            if (isObject<{ lowerPos: unknown; items: unknown }>(x)) {
                const pos = f(x.lowerPos)
                const items = g(x.items)
                if (pos !== undefined && items !== undefined) {
                    return new Block(pos, items)
                }
            }
            return undefined
        }
    }

    // Access
    /**
     * Length of {@link Block#items }
     */
    get length(): u32 {
        return this.items.length
    }

    /**
     * @example
     * b.nthPos(0) == b.lowerPos
     * b.nthPos(b.length - 1) == b.upperPos
     *
     * @param nth 0-based index
     * @return {@link nth } -th position of the block.
     */
    nthPos(nth: u32): P {
        assert(() => isU32(nth), "nth ∈ u32")
        assert(() => nth < this.length, "nth < this.length")
        if (nth === 0) {
            return this.lowerPos
        } else {
            return this.lowerPos.intSucc(nth)
        }
    }

    /**
     * Last position of the block.
     */
    upperPos(): P {
        return this.nthPos(this.length - 1)
    }

    /**
     * @param index 0-based index
     *      {@link index } < {@link Block#length }
     * @return Anchor at {@link index }
     */
    anchorAt(index: u32): Anchor<P> {
        assert(() => isU32(index), "index ∈ u32")
        assert(() => index < this.length, "index < this.length")
        return new Anchor(this.nthPos(index))
    }

    /**
     * Globally unique identifier of the author which generated this block.
     */
    replica(): u32 {
        return this.lowerPos.replica()
    }

    /**
     * When each position of this block were generated.
     */
    seqs(): IntInterval {
        return IntInterval.fromLength(this.lowerPos.seq(), this.length)
    }

    /**
     * @param other splitting block
     *      {@link other } must split this
     * @return 0-based index where {@link other } splits this block.
     */
    splittingIndex(other: BaseBlockk<P>): u32 {
        heavyAssert(
            () => this.compare(other) === BlockOrdering.SPLITTED_BY,
            "other splits this"
        )

        const [dist] = this.lowerPos.intDistance(other.lowerPos)
        return dist + 1
    }

    /**
     * @return Length block representation of this block.
     */
    toLengthBlock(): LengthBlock<P> {
        const concatLength = new ConcatLength(this.length)
        return new Block(this.lowerPos, concatLength)
    }

    /**
     * Hash code.
     * Note that the content is not take into account.
     */
    structuralDigest(): u32 {
        return digestOf([this.lowerPos.digest(), this.length])
    }

    // Status
    /**
     * @return Is this block a length block?
     */
    isLengthBlock(): this is LengthBlock<P> {
        return this.items instanceof ConcatLength
    }

    /**
     * @param other
     * @return Are this and {@link other } an intersection?
     */
    hasIntersection(other: BaseBlockk<P>): boolean {
        const cmp = this.compare(other)
        return (
            cmp === BlockOrdering.OVERLAPPING_BEFORE ||
            cmp === BlockOrdering.OVERLAPPING_AFTER ||
            cmp === BlockOrdering.EQUAL ||
            cmp === BlockOrdering.INCLUDING ||
            cmp === BlockOrdering.INCLUDED_BY
        )
    }

    /**
     * @param other
     * @return Has this an appendable segment to {@link other }?
     */
    hasAppendable(other: BaseBlockk<P>): boolean {
        const cmp = this.compare(other)
        return (
            cmp === BlockOrdering.OVERLAPPING_AFTER ||
            (cmp === BlockOrdering.INCLUDING &&
                this.upperPos().compare(other.upperPos()) === Ordering.AFTER)
        )
    }

    /**
     * @param other
     * @return Has this a prependable segment to {@link other }?
     */
    hasPrependable(other: BaseBlockk<P>): boolean {
        const cmp = this.compare(other)
        return (
            cmp === BlockOrdering.OVERLAPPING_BEFORE ||
            (cmp === BlockOrdering.INCLUDING &&
                this.lowerPos.compare(other.lowerPos) === Ordering.BEFORE)
        )
    }

    /**
     * @example
     * a.compare(b) == Ordering.Before if a < b
     *
     * @param other
     * @return this [Order relation] {@link other}.
     */
    compare(other: BaseBlockk<P>): BlockOrdering {
        const baseCmp = this.lowerPos.compareBase(other.lowerPos)

        if (baseCmp === BaseOrdering.BEFORE) {
            return BlockOrdering.BEFORE // Before meta block
        } else if (baseCmp === BaseOrdering.AFTER) {
            return BlockOrdering.AFTER // After meta block
        } else {
            const [dist, order] = this.lowerPos.intDistance(other.lowerPos)

            if (baseCmp === BaseOrdering.EQUAL) {
                const lower1 = order === Ordering.BEFORE ? 0 : dist
                const thisInterval = IntInterval.fromLength(lower1, this.length)

                const lower2 = order === Ordering.BEFORE ? dist : 0
                const otherInterval = IntInterval.fromLength(
                    lower2,
                    other.length
                )

                const intervalCmp = thisInterval.compare(otherInterval)
                return intervalOrderingAsBlockOrdering[intervalCmp]
            } else if (baseCmp === BaseOrdering.PREFIXING) {
                if (order === Ordering.AFTER) {
                    return BlockOrdering.AFTER
                } else if (dist >= this.length - 1) {
                    return BlockOrdering.BEFORE
                } else {
                    return BlockOrdering.SPLITTED_BY
                }
            } else {
                if (order === Ordering.BEFORE) {
                    return BlockOrdering.BEFORE
                } else if (dist >= other.length - 1) {
                    return BlockOrdering.AFTER
                } else {
                    return BlockOrdering.SPLITTING
                }
            }
        }
    }

    // Derivation
    /**
     * @example
     * Block(p, "ab").append(Block(_, "cd")) == Block(p, "abcd")
     *
     * @param other
     *      {@link other } is appendable to this.
     * @return other appended to this.
     */
    append(other: Block<P, E>): Block<P, E> {
        heavyAssert(
            () => other.compare(this) === BlockOrdering.APPENDABLE,
            "other is appendable to this"
        )
        return new Block(this.lowerPos, this.items.concat(other.items))
    }

    /**
     * @example
     * Block(p, "ab").leftSplitAt(1) == Block(p, "a")
     * Block(p, "ab").leftSplitAt(2) == Block(p, "ab")
     *
     * @param index 0-based index
     *      0 < {@link index } <= {@link Block#length }
     * @return Left split.
     */
    leftSplitAt(index: u32): Block<P, E> {
        assert(() => isU32(index), "index ∈ u32")
        assert(
            () => 0 < index && index <= this.length,
            "0 < index <= this.length"
        )
        const leftItems = this.items.slice(0, index)
        return new Block(this.lowerPos, leftItems)
    }

    /**
     * @example
     * Block(p, "ab").rightSplitAt(1) == Block(p+1, "b")
     * Block(p, "ab").rightSplitAt(0) == Block(p, "ab")
     *
     * @param index 0-based index
     *      {@link index } < this.length
     * @return Right split.
     */
    rightSplitAt(index: u32): Block<P, E> {
        assert(() => isU32(index), "index ∈ u32")
        assert(() => index < this.length, "0 <= index < this.length")
        const rightItems = this.items.slice(index, this.length)
        const rightPos = this.nthPos(index)
        return new Block(rightPos, rightItems)
    }

    /**
     * @example
     * b.splitAt(n) == [b.leftSplitAt(n), b.rightSplitAt(n)]
     *
     * @param index 0-based index
     *      0 < {@link index } < {@link Block#length }
     * @return Left and right splits.
     */
    splitAt(index: u32): [Block<P, E>, Block<P, E>] {
        assert(() => isU32(index), "index ∈ u32")
        assert(
            () => 0 < index && index < this.length,
            "0 < index < this.length"
        )
        return [this.leftSplitAt(index), this.rightSplitAt(index)]
    }

    /**
     * @param other splitting block
     *      {@link other } must split this
     * @return Left and right splits.
     */
    splitWith(other: BaseBlockk<P>): [Block<P, E>, Block<P, E>] {
        assert(
            () => this.compare(other) === BlockOrdering.SPLITTED_BY,
            "other splits this"
        )
        return this.splitAt(this.splittingIndex(other))
    }

    /**
     * @param other
     *      this includes or overlaps after {@link other }
     * @return Part of this block which can be append to {@link block }.
     */
    appendable(other: BaseBlockk<P>): Block<P, E> {
        heavyAssert(
            () => this.hasAppendable(other),
            "this has an appendable segment to other"
        )

        const [dist, order] = this.lowerPos.intDistance(other.lowerPos)
        if (order === Ordering.BEFORE) {
            return this.rightSplitAt(other.length + dist)
        } else {
            return this.rightSplitAt(other.length - dist)
        }
    }

    /**
     * @param other
     *      this includes or overlaps before {@link other }
     * @return Part of this block which can be prepend to {@link block }.
     */
    prependable(other: BaseBlockk<P>): Block<P, E> {
        heavyAssert(
            () => this.hasPrependable(other),
            "this has a prependable segment to other"
        )

        const [dist] = this.lowerPos.intDistance(other.lowerPos)
        return this.leftSplitAt(dist)
    }

    /**
     * @param other
     *      this and {@link other } intersect.
     * @return Intersection part between this and {@link other }.
     */
    intersection(other: BaseBlockk<P>): Block<P, E> {
        heavyAssert(() => this.hasIntersection(other), "this intersects other.")

        const [dist, order] = this.lowerPos.intDistance(other.lowerPos)
        if (order === Ordering.BEFORE) {
            const pos = other.lowerPos
            const l = Math.min(this.length - dist, other.length)
            const elements = this.items.slice(dist, dist + l)
            return new Block(pos, elements)
        } else {
            const pos = this.lowerPos
            const l = Math.min(other.length - dist, this.length)
            const elements = this.items.slice(0, l)
            return new Block(pos, elements)
        }
    }

    /**
     * @example
     * Block(p, "abc").remove(Block(p, "a")) == [undefined, Block(p+1, "bc")]
     * Block(p, "abc").remove(Block(p+1, "b")) == [Block(_, "a"), Block(p+2, "c")]
     * Block(p, "abc").remove(Block(p+2, "c")) == [Block(p, "ab"), undefined]
     * Block(p, "abc").remove(Block(p+3, "d")) == [undefined, undefined]
     *
     * @param other
     * @return Left and right remaining after removing from this the
     *  intersection between this and {@link other }.
     */
    remove(
        other: BaseBlockk<P>
    ): [Block<P, E> | undefined, Block<P, E> | undefined] {
        heavyAssert(
            () => this.hasIntersection(other),
            "this and other intersect."
        )

        const [dist, order] = this.lowerPos.intDistance(other.lowerPos)
        if (order === Ordering.BEFORE) {
            const removedLength = this.length - dist
            if (removedLength > other.length) {
                return [this.prependable(other), this.appendable(other)]
            } else {
                return [this.prependable(other), undefined]
            }
        } else {
            const removedLength = other.length - dist
            if (removedLength >= this.length) {
                return [undefined, undefined]
            } else {
                return [undefined, this.appendable(other)]
            }
        }
    }
}
