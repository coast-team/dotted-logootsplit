/*
    Copyright (C) 2018  Victorien Elvinger

    This Source Code Form is subject to the terms of the Mozilla Public
    License, v. 2.0. If a copy of the MPL was not distributed with this
    file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

import { assert, heavyAssert } from "../util/assert.js"
import { FromPlain, isObject } from "../util/data-validation.js"
import type { u32 } from "../util/number.js"
import { hashCodeOf, isU32 } from "../util/number.js"
import { Ordering } from "../util/ordering.js"
import { Anchor } from "./anchor.js"
import { Concat, ConcatLength } from "./concat.js"
import { BaseOrdering, Pos } from "./pos.js"
import { RangeOrdering, U32Range } from "./u32-range.js"

/**
 * Possible relation between two blocks.
 *
 * Same semantic as {@link IntervalOrdering }.
 * @example
 * [0, 2] |⊂ 1[_, _]
 */
export type BlockOrdering =
    | 0
    | 1
    | 2
    | 3
    | 4
    | 5
    | 6
    | 7
    | 8
    | 9
    | 10
    | 11
    | 12
    | 13
    | 14
export const BlockOrdering = {
    // TODO: add "AfterVirtualBlock" & "BeforeVirtualBlock" (with better names)?
    BEFORE: 0, // <
    PREPENDABLE: 1, // <:
    SPLITTED_BY: 2, // |⊂
    OVERLAPPING_BEFORE: 3, // <∩
    INCLUDED_LEFT_BY: 4, // +⊂
    INCLUDED_MIDDLE_BY: 5, // ⊂
    INCLUDED_RIGHT_BY: 6, // -⊂
    EQUAL: 7, //:
    INCLUDING_LEFT: 8, // ⊃-
    INCLUDING_MIDDLE: 9, // ⊃
    INCLUDING_RIGHT: 10, // ⊃+
    OVERLAPPING_AFTER: 11, // >∩
    SPLITTING: 12, // ⊃|
    APPENDABLE: 13, // :>
    AFTER: 14, // >
} as const

/**
 * Map IntervalOrdering to BlockOrdering.
 */
const rangeOrderingAsBlockOrdering = [
    BlockOrdering.BEFORE,
    BlockOrdering.PREPENDABLE,
    BlockOrdering.OVERLAPPING_BEFORE,
    BlockOrdering.INCLUDED_LEFT_BY,
    BlockOrdering.INCLUDED_MIDDLE_BY,
    BlockOrdering.INCLUDED_RIGHT_BY,
    BlockOrdering.EQUAL,
    BlockOrdering.INCLUDING_LEFT,
    BlockOrdering.INCLUDING_MIDDLE,
    BlockOrdering.INCLUDING_RIGHT,
    BlockOrdering.OVERLAPPING_AFTER,
    BlockOrdering.APPENDABLE,
    BlockOrdering.AFTER,
] as const

/**
 * A {@see Block} or a {@see LengthBlock}.
 */
export interface BaseBlock {
    /**
     * First position of the block.
     */
    readonly lowerPos: Pos

    /**
     * Last position of the block.
     */
    readonly upperPos: () => Pos

    /**
     * Block length.
     */
    readonly length: u32
}

/**
 * Represent the removal of a segment.
 */
export type LengthBlock = Block<ConcatLength>

/**
 * Segment of concatenable elements generated by the same author.
 *
 * A segment can be represented as a set of int successive positions
 * (see {@link Pos }) and an attached content.
 */
export class Block<E extends Concat<E>> {
    /**
     * @param lowerPos First position of the block.
     * @param content Content of the block.
     */
    constructor(readonly lowerPos: Pos, readonly content: E) {
        assert(() => content.length > 0, "content.length > 0")
        assert(() => lowerPos.hasIntSucc(content.length - 1), "valid positions")
    }

    /**
     * @param posFromPlain
     * @param itemsFromPlain
     * @return function that accepts a value and attempt to build a block.
     *  It returns the built block if it succeeds, or undefined if it fails.
     */
    static fromPlain<E extends Concat<E>>(
        itemsFromPlain: FromPlain<E>
    ): FromPlain<Block<E>> {
        return (x: unknown) => {
            if (isObject<{ lowerPos: unknown; content: unknown }>(x)) {
                const pos = Pos.fromPlain(x.lowerPos)
                const content = itemsFromPlain(x.content)
                if (pos !== undefined && content !== undefined) {
                    return new Block(pos, content)
                }
            }
            return undefined
        }
    }

    // Access
    /**
     * Length of {@link Block#content }
     */
    get length(): u32 {
        return this.content.length
    }

    /**
     * @example
     * b.nthPos(0) == b.lowerPos
     * b.nthPos(b.length - 1) == b.upperPos
     *
     * @param nth 0-based index
     * @return {@link nth } -th position of the block.
     */
    nthPos(nth: u32): Pos {
        assert(() => isU32(nth), "nth ∈ u32")
        assert(() => nth < this.length, "nth < this.length")
        if (nth === 0) {
            return this.lowerPos
        } else {
            return this.lowerPos.intSucc(nth)
        }
    }

    /**
     * Last position of the block.
     */
    upperPos(): Pos {
        return this.nthPos(this.length - 1)
    }

    /**
     * @return anchor just before the lower position
     */
    lowerAnchor(): Anchor {
        return this.anchor(0, false)
    }

    /**
     * @param nth 0-based index
     * @param isAfter is the anchor after the `nth` position?
     * @return Anchor relative to the `nth` position of the block.
     */
    anchor(nth: u32, isAfter: boolean): Anchor {
        assert(() => isU32(nth), "nth ∈ u32")
        assert(() => nth < this.length, "nth < this.length")
        return new Anchor(this.nthPos(nth), isAfter)
    }

    /**
     * @return anchor just after the upper position
     */
    upperAnchor(): Anchor {
        return this.anchor(this.length - 1, true)
    }

    /**
     * Globally unique identifier of the author which generated this block.
     */
    replica(this: BaseBlock): u32 {
        return this.lowerPos.replica()
    }

    /**
     * When each position of this block were generated.
     */
    seqs(this: BaseBlock): U32Range {
        return U32Range.fromLength(this.lowerPos.seq, this.length)
    }

    /**
     * @param other splitting block
     *      {@link other } must split this
     * @return 0-based index where {@link other } splits this block.
     */
    splittingIndex(other: BaseBlock): u32 {
        heavyAssert(
            () => this.compare(other) === BlockOrdering.SPLITTED_BY,
            "other splits this"
        )

        const [dist] = this.lowerPos.intDistance(other.lowerPos)
        return dist + 1
    }

    /**
     * @return Length block representation of this block.
     */
    toLengthBlock(): LengthBlock {
        const concatLength = new ConcatLength(this.length)
        return new Block(this.lowerPos, concatLength)
    }

    /**
     * Non-cryptographic way to approximate object identity.
     * Do not take the content into account.
     */
    structuralHashCode(): u32 {
        return hashCodeOf([this.lowerPos.hashCode(), this.length])
    }

    // Status
    /**
     * @return Is this block a length block?
     */
    isLengthBlock(): this is LengthBlock {
        return this.content instanceof ConcatLength
    }

    /**
     * @param other
     * @return Are this and {@link other } an intersection?
     */
    hasIntersection(other: BaseBlock): boolean {
        const cmp = this.compare(other)
        return (
            BlockOrdering.OVERLAPPING_BEFORE <= cmp &&
            cmp <= BlockOrdering.OVERLAPPING_AFTER
        )
    }

    /**
     * @param other
     * @return Has this an appendable segment to {@link other }?
     */
    hasAppendable(other: BaseBlock): boolean {
        const cmp = this.compare(other)
        return (
            cmp === BlockOrdering.OVERLAPPING_AFTER ||
            cmp === BlockOrdering.INCLUDING_LEFT ||
            cmp === BlockOrdering.INCLUDING_MIDDLE
        )
    }

    /**
     * @param other
     * @return Has this a prependable segment to {@link other }?
     */
    hasPrependable(other: BaseBlock): boolean {
        const cmp = this.compare(other)
        return (
            cmp === BlockOrdering.OVERLAPPING_BEFORE ||
            cmp === BlockOrdering.INCLUDING_RIGHT ||
            cmp === BlockOrdering.INCLUDING_MIDDLE
        )
    }

    /**
     * @param anchor
     * @return A pair that includes the index of `anchor` in the block and
     *  its order relation.
     *  Ordering.EQUAL means that {@link anchor} is related to a position
     *  of this block.
     */
    indexFrom(anchor: Anchor): u32 {
        const baseCmp = this.lowerPos.compareBase(anchor.ref)

        if (baseCmp === BaseOrdering.BEFORE) {
            return this.length
        } else if (baseCmp === BaseOrdering.AFTER) {
            return 0
        } else {
            const [dist, order] = this.lowerPos.intDistance(anchor.ref)

            if (order === Ordering.BEFORE) {
                return this.length
            } else if (dist >= this.length) {
                return 0
            } else {
                if (anchor.isAfter) {
                    return dist + 1
                } else {
                    return dist
                }
            }
        }
    }

    /**
     * @example
     * a.compare(b) == Ordering.Before if a < b
     *
     * @param other
     * @return this [Order relation] {@link other}.
     */
    compare(other: BaseBlock): BlockOrdering {
        const baseCmp = this.lowerPos.compareBase(other.lowerPos)

        if (baseCmp === BaseOrdering.BEFORE) {
            return BlockOrdering.BEFORE // Before meta block
        } else if (baseCmp === BaseOrdering.AFTER) {
            return BlockOrdering.AFTER // After meta block
        } else {
            const [dist, order] = this.lowerPos.intDistance(other.lowerPos)

            if (baseCmp === BaseOrdering.EQUAL) {
                const lower1 = order === Ordering.BEFORE ? 0 : dist
                const thisInterval = U32Range.fromLength(lower1, this.length)

                const lower2 = order === Ordering.BEFORE ? dist : 0
                const otherInterval = U32Range.fromLength(lower2, other.length)

                const intervalCmp = thisInterval.compare(otherInterval)
                return rangeOrderingAsBlockOrdering[intervalCmp]
            } else if (baseCmp === BaseOrdering.PREFIXING) {
                if (order === Ordering.AFTER) {
                    return BlockOrdering.AFTER
                } else if (dist >= this.length - 1) {
                    return BlockOrdering.BEFORE
                } else {
                    return BlockOrdering.SPLITTED_BY
                }
            } else {
                if (order === Ordering.BEFORE) {
                    return BlockOrdering.BEFORE
                } else if (dist >= other.length - 1) {
                    return BlockOrdering.AFTER
                } else {
                    return BlockOrdering.SPLITTING
                }
            }
        }
    }

    // Derivation
    /**
     * @example
     * Block(p, "ab").append(Block(_, "cd")) == Block(p, "abcd")
     *
     * @param other
     *      {@link other } is appendable to this.
     * @return other appended to this.
     */
    append(other: Block<E>): Block<E> {
        heavyAssert(
            () => other.compare(this) === BlockOrdering.APPENDABLE,
            "other is appendable to this"
        )
        return new Block(this.lowerPos, this.content.concat(other.content))
    }

    /**
     * @example
     * Block(p, "ab").leftSplitAt(1) == Block(p, "a")
     * Block(p, "ab").leftSplitAt(2) == Block(p, "ab")
     *
     * @param index 0-based index
     *      0 < {@link index } <= {@link Block#length }
     * @return Left split.
     */
    leftSplitAt(index: u32): Block<E> {
        assert(() => isU32(index), "index ∈ u32")
        assert(
            () => 0 < index && index <= this.length,
            "0 < index <= this.length"
        )
        const leftItems = this.content.slice(0, index)
        return new Block(this.lowerPos, leftItems)
    }

    /**
     * @example
     * Block(p, "ab").rightSplitAt(1) == Block(p+1, "b")
     * Block(p, "ab").rightSplitAt(0) == Block(p, "ab")
     *
     * @param index 0-based index
     *      {@link index } < this.length
     * @return Right split.
     */
    rightSplitAt(index: u32): Block<E> {
        assert(() => isU32(index), "index ∈ u32")
        assert(() => index < this.length, "0 <= index < this.length")
        const rightItems = this.content.slice(index, this.length)
        const rightPos = this.nthPos(index)
        return new Block(rightPos, rightItems)
    }

    /**
     * @example
     * b.splitAt(n) == [b.leftSplitAt(n), b.rightSplitAt(n)]
     *
     * @param index 0-based index
     *      0 < {@link index } < {@link Block#length }
     * @return Left and right splits.
     */
    splitAt(index: u32): readonly [Block<E>, Block<E>] {
        assert(() => isU32(index), "index ∈ u32")
        assert(
            () => 0 < index && index < this.length,
            "0 < index < this.length"
        )
        return [this.leftSplitAt(index), this.rightSplitAt(index)]
    }

    /**
     * @param other splitting block
     *      {@link other } must split this
     * @return Left and right splits.
     */
    splitWith(other: BaseBlock): readonly [Block<E>, Block<E>] {
        assert(
            () => this.compare(other) === BlockOrdering.SPLITTED_BY,
            "other splits this"
        )
        return this.splitAt(this.splittingIndex(other))
    }

    /**
     * @param other
     *      this includes or overlaps after {@link other }
     * @return Part of this block which can be append to {@link block }.
     */
    appendable(other: BaseBlock): Block<E> {
        heavyAssert(
            () => this.hasAppendable(other),
            "this has an appendable segment to other"
        )

        const [dist, order] = this.lowerPos.intDistance(other.lowerPos)
        if (order === Ordering.BEFORE) {
            return this.rightSplitAt(other.length + dist)
        } else {
            return this.rightSplitAt(other.length - dist)
        }
    }

    /**
     * @param other
     *      this includes or overlaps before {@link other }
     * @return Part of this block which can be prepend to {@link block }.
     */
    prependable(other: BaseBlock): Block<E> {
        heavyAssert(
            () => this.hasPrependable(other),
            "this has a prependable segment to other"
        )

        const [dist] = this.lowerPos.intDistance(other.lowerPos)
        return this.leftSplitAt(dist)
    }

    /**
     * @param other
     *      this and {@link other } intersect.
     * @return Intersection part between this and {@link other }.
     */
    intersection(other: BaseBlock): Block<E> {
        heavyAssert(() => this.hasIntersection(other), "this intersects other.")

        const [dist, order] = this.lowerPos.intDistance(other.lowerPos)
        if (order === Ordering.BEFORE) {
            const pos = other.lowerPos
            const l = Math.min(this.length - dist, other.length)
            const elements = this.content.slice(dist, dist + l)
            return new Block(pos, elements)
        } else {
            const pos = this.lowerPos
            const l = Math.min(other.length - dist, this.length)
            const elements = this.content.slice(0, l)
            return new Block(pos, elements)
        }
    }
}
