/*
    Copyright (C) 2018  Victorien Elvinger

    This Source Code Form is subject to the terms of the Mozilla Public
    License, v. 2.0. If a copy of the MPL was not distributed with this
    file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

import { assert, heavyAssert, readonly } from "./assert"
import { isObject, FromPlain } from "../core/data-validation"
import { digestOf, isUint32, uint32 } from "./number"
import { Anchor } from "./anchor"
import { Position, BaseOrdering } from "./position"
import { Concatenable, ConcatenableLength } from "./concatenable"
import { IntervalOrdering, IntInterval } from "./intinterval"
import { Ordering } from "./ordering"

/**
 * Possible relation between two blocks.
 *
 * Same semantic as {@link IntervalOrdering }.
 * @example
 * [0, 2] |⊂ 1[_, _]
 */
export const enum BlockOrdering {
    // TODO: add "AfterVirtualBlock" & "BeforeVirtualBlock" (with better names)?
    BEFORE = -5, // <
    PREPENDABLE = -4, // <:
    OVERLAPPING_BEFORE = -3, // <∩
    SPLITTED_BY = -2, // |⊂
    INCLUDED_BY = -1, // ⊂
    EQUAL = 0, // =
    INCLUDING = 1, // ⊃
    SPLITTING = 2, // ⊃|
    OVERLAPPING_AFTER = 3, // >∩
    APPENDABLE = 4, // :>
    AFTER = 5 // >
}

/**
 * Map IntervalOrdering to BlockOrdering.
 */
const intervalOrderingAsBlockOrdering = readonly({
    [IntervalOrdering.BEFORE]: BlockOrdering.BEFORE,
    [IntervalOrdering.PREPENDABLE]: BlockOrdering.PREPENDABLE,
    [IntervalOrdering.OVERLAPPING_BEFORE]: BlockOrdering.OVERLAPPING_BEFORE,
    [IntervalOrdering.INCLUDING]: BlockOrdering.INCLUDING,
    [IntervalOrdering.EQUAL]: BlockOrdering.EQUAL,
    [IntervalOrdering.INCLUDED_BY]: BlockOrdering.INCLUDED_BY,
    [IntervalOrdering.OVERLAPPING_AFTER]: BlockOrdering.OVERLAPPING_AFTER,
    [IntervalOrdering.APPENDABLE]: BlockOrdering.APPENDABLE,
    [IntervalOrdering.AFTER]: BlockOrdering.AFTER,
})

/**
 * Represent the removal of a segment.
 */
export type LengthBlock <P extends Position<P>> = Block<P, ConcatenableLength>

/**
 * Segment of concatenable elements generated by a same participant.
 *
 * A segment can be represented as a set of int successive positions
 * (see {@link Position }) and an attached content (items).
 */
export class Block <P extends Position<P>, E extends Concatenable<E>> {
    /**
     * @param lowerPosition {@link lowerPosition }
     * @param items {@link items }
     */
    constructor (lowerPosition: P, items: E) {
        assert(() => items.length > 0, "items.length > 0")
        assert(() => lowerPosition.hasIntSuccessor(items.length - 1),
            "all positions are valid")
        this.lowerPosition = lowerPosition
        this.items = items
    }

    static fromPlain <P extends Position<P>, E extends Concatenable<E>>
        (f: FromPlain<P>, g: FromPlain<E>): FromPlain<Block<P, E>> {

        return (x: unknown) => {
            if (isObject<{ lowerPosition: unknown, items: unknown }>(x)) {
                const pos = f(x.lowerPosition)
                const items = g(x.items)
                if (pos !== undefined && items !== undefined) {
                    return new Block(pos, items)
                }
            }
            return undefined
        }
    }

// Access
    /**
     * First position of the block.
     */
    readonly lowerPosition: P

    /**
     * Content of the block.
     */
    readonly items: E

    /**
     * Length of {@link Block#items }
     */
    get length (): uint32 {
        return this.items.length
    }

    /**
     * @example
     * b.nthPosition(0) == b.lowerPositions
     * b.nthPosition(b.length - 1) == b.upperPosition
     *
     * @param nth 0-based index
     * @return {@link nth } -th position of the block.
     */
    nthPosition (nth: uint32): P {
        assert(() => isUint32(nth), "nth ∈ uint32")
        assert(() => nth < this.length, "nth < this.length")
        if (nth === 0) {
            return this.lowerPosition
        } else {
            return this.lowerPosition.intSuccessor(nth)
        }
    }

    /**
     * Last position of the block.
     */
    get upperPosition (): P {
        return this.nthPosition(this.length - 1)
    }

    /**
     * @param index 0-based index
     *      {@link index } < {@link Block#length }
     * @return Anchor at {@link index }
     */
    anchorAt (index: uint32): Anchor<P> {
        assert(() => isUint32(index), "index ∈ uint32")
        assert(() => index < this.length, "index < this.length")
        return new Anchor(this.nthPosition(index))
    }

    /**
     * Globally unique identifier of the author which generated this block.
     */
    get replica (): uint32 {
        return this.lowerPosition.replica
    }

    /**
     * When each position of this block were generated.
     */
    get seqs (): IntInterval {
        return IntInterval.fromLength(this.lowerPosition.seq, this.length)
    }

    /**
     * @param other splitting block
     *      {@link other } must split this
     * @return 0-based index where {@link other } splits this block.
     */
    splittingIndex (other: Block<P, E> | LengthBlock<P>): uint32 {
        heavyAssert(() => this.compare(other) === BlockOrdering.SPLITTED_BY,
            "other splits this")

        const [dist, ] = this.lowerPosition.intDistance(other.lowerPosition)
        return dist + 1
    }

    /**
     * @return Length block representation of this block.
     */
    toLengthBlock (): LengthBlock<P> {
        const concatLength = new ConcatenableLength(this.length)
        return new Block(this.lowerPosition, concatLength)
    }

    /**
     * Hash code.
     * Note that the content is not take into account.
     */
    get structuralDigest (): uint32 {
        return digestOf([this.lowerPosition.digest, this.length])
    }

// Status
    /**
     * @return Is this block a length block?
     */
    isLengthBlock (): this is LengthBlock<P> {
        return this.items instanceof ConcatenableLength
    }

    /**
     * @param other
     * @return Are this and {@link other } an intersection?
     */
    hasIntersection (other: Block<P, E> | LengthBlock<P>): boolean {
        const cmp = this.compare(other)
        return cmp === BlockOrdering.OVERLAPPING_BEFORE ||
        cmp === BlockOrdering.OVERLAPPING_AFTER || cmp === BlockOrdering.EQUAL ||
        cmp === BlockOrdering.INCLUDING || cmp === BlockOrdering.INCLUDED_BY
    }

    /**
     * @example
     * a.compare(b) == Ordering.Before if a < b
     *
     * @param other
     * @return this [Order relation] {@link other}.
     */
    compare (other: Block<P, E> | LengthBlock<P>): BlockOrdering {
        const baseCmp = this.lowerPosition.compareBase(other.lowerPosition)

        if (baseCmp === BaseOrdering.BEFORE) {
            return BlockOrdering.BEFORE // Before meta block
        } else if (baseCmp === BaseOrdering.AFTER) {
            return BlockOrdering.AFTER // After meta block
        } else {
            const [dist, order] = this.lowerPosition.intDistance(other.lowerPosition)

            if (baseCmp === BaseOrdering.EQUAL) {
                const lower1 = (order === Ordering.BEFORE) ? 0 : dist
                const thisInterval = IntInterval.fromLength(lower1, this.length)

                const lower2 = (order === Ordering.BEFORE) ? dist : 0
                const otherInterval = IntInterval.fromLength(lower2, other.length)

                const intervalCmp = thisInterval.compare(otherInterval)
                return intervalOrderingAsBlockOrdering[intervalCmp]
            } else if (baseCmp === BaseOrdering.PREFIXING) {
                if (order === Ordering.AFTER) {
                    return BlockOrdering.AFTER
                } else if (dist >= (this.length - 1)) {
                    return BlockOrdering.BEFORE
                } else {
                    return BlockOrdering.SPLITTED_BY
                }
            } else {
                if (order === Ordering.BEFORE) {
                    return BlockOrdering.BEFORE
                } else if (dist >= (other.length - 1)) {
                    return BlockOrdering.AFTER
                } else {
                    return BlockOrdering.SPLITTING
                }
            }
        }
    }

// Derivation
    /**
     * @example
     * Block(p, "ab").append(Block(_, "cd")) == Block(p, "abcd")
     *
     * @param other
     *      {@link other } is appendable to this.
     * @return other appended to this.
     */
    append (other: Block<P, E>): Block<P, E> {
        heavyAssert(() => other.compare(this) === BlockOrdering.APPENDABLE,
            "other is appendable to this")
        return new Block(this.lowerPosition, this.items.concat(other.items))
    }

    /**
     * @example
     * Block(p, "ab").leftSplitAt(1) == Block(p, "a")
     * Block(p, "ab").leftSplitAt(2) == Block(p, "ab")
     *
     * @param index 0-based index
     *      0 < {@link index } <= {@link Block#length }
     * @return Left split.
     */
    leftSplitAt (index: uint32): Block<P, E> {
        assert(() => isUint32(index), "index ∈ uint32")
        assert(() => 0 < index && index <= this.length, "0 < index <= this.length")
        const leftItems = this.items.slice(0, index)
        return new Block(this.lowerPosition, leftItems)
    }

    /**
     * @example
     * Block(p, "ab").rightSplitAt(1) == Block(p+1, "b")
     * Block(p, "ab").rightSplitAt(0) == Block(p, "ab")
     *
     * @param index 0-based index
     *      {@link index } < this.length
     * @return Right split.
     */
    rightSplitAt (index: uint32): Block<P, E> {
        assert(() => isUint32(index), "index ∈ uint32")
        assert(() => index < this.length, "0 <= index < this.length")
        const rightItems = this.items.slice(index, this.length)
        const rightPosition = this.nthPosition(index)
        return new Block(rightPosition, rightItems)
    }

    /**
     * @example
     * b.splitAt(n) == [b.leftSplitAt(n), b.rightSplitAt(n)]
     *
     * @param index 0-based index
     *      0 < {@link index } < {@link Block#length }
     * @return Left and right splits.
     */
    splitAt (index: uint32): [Block<P, E>, Block<P, E>] {
        assert(() => isUint32(index), "index ∈ uint32")
        assert(() => 0 < index && index < this.length, "0 < index < this.length")
        return [this.leftSplitAt(index), this.rightSplitAt(index)]
    }

    /**
     * @param other splitting block
     *      {@link other } must split this
     * @return Left and right splits.
     */
    splitWith (other: Block<P, E> | LengthBlock<P>): [Block<P, E>, Block<P, E>] {
        assert(() => this.compare(other) === BlockOrdering.SPLITTED_BY,
            "other splits this")
        return this.splitAt(this.splittingIndex(other))
    }

    /**
     * @param other
     *      this includes or overlaps after {@link other }
     * @return Part of this block which can be append to {@link block }.
     */
    appendable (other: Block<P, E> | LengthBlock<P>): Block<P, E> {
        heavyAssert(() => ((cmp) =>
            cmp === BlockOrdering.OVERLAPPING_AFTER ||
            cmp === BlockOrdering.INCLUDING
        )(this.compare(other)), "this has an appendable segment to other")

        const [dist, order] = this.lowerPosition.intDistance(other.lowerPosition)
        if (order === Ordering.BEFORE) {
            return this.rightSplitAt(other.length + dist)
        } else {
            return this.rightSplitAt(other.length - dist)
        }
    }

    /**
     * @param other
     *      this includes or overlaps before {@link other }
     * @return Part of this block which can be prepend to {@link block }.
     */
    prependable (other: Block<P, E> | LengthBlock<P>): Block<P, E> {
        heavyAssert(() => ((cmp) =>
            cmp === BlockOrdering.OVERLAPPING_BEFORE ||
            cmp === BlockOrdering.INCLUDING
        )(this.compare(other)), "this has a prependable segment to other")

        const [dist, ] = this.lowerPosition.intDistance(other.lowerPosition)
        return this.leftSplitAt(dist)
    }

    /**
     * @param other
     *      this and {@link other } intersect.
     * @return Intersection part between this and {@link other }.
     */
    intersection (other: Block<P, E> | LengthBlock<P>): Block<P, E> {
        heavyAssert(() => this.hasIntersection(other), "this and other intersect.")

        const [dist, order] = this.lowerPosition.intDistance(other.lowerPosition)
        if (order === Ordering.BEFORE) {
            const pos = other.lowerPosition
            const l = Math.min(this.length - dist, other.length)
            const elements = this.items.slice(dist, dist + l)
            return new Block(pos, elements)
        } else {
            const pos = this.lowerPosition
            const l = Math.min(other.length - dist, this.length)
            const elements = this.items.slice(0, l)
            return new Block(pos, elements)
        }
    }

    /**
     * @example
     * Block(p, "abc").remove(Block(p, "a")) == [undefined, Block(p+1, "bc")]
     * Block(p, "abc").remove(Block(p+1, "b")) == [Block(_, "a"), Block(p+2, "c")]
     * Block(p, "abc").remove(Block(p+2, "c")) == [Block(p, "ab"), undefined]
     * Block(p, "abc").remove(Block(p+3, "d")) == [undefined, undefined]
     *
     * @param other
     * @return Left and right remaining after removing from this the
     *  intersection between this and {@link other }.
     */
    remove (other: Block<P, E> | LengthBlock<P>): [Block<P, E> | undefined, Block<P, E> | undefined] {
        heavyAssert(() => this.hasIntersection(other), "this and other intersect.")

        const [dist, order] = this.lowerPosition.intDistance(other.lowerPosition)
        if (order === Ordering.BEFORE) {
            const removedLength = this.length - dist
            if (removedLength > other.length) {
                return [this.prependable(other), this.appendable(other)]
            } else {
                return [this.prependable(other), undefined]
            }
        } else {
            const removedLength = other.length - dist
            if (removedLength >= this.length) {
                return [undefined, undefined]
            } else {
                return [undefined, this.appendable(other)]
            }
        }
    }
}
